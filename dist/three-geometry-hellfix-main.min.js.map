{"version":3,"file":"three-geometry-hellfix-main.min.js","mappings":"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","sources":["webpack://three-geometry-hellfix/./src/cjs/DefaultFactory.js","webpack://three-geometry-hellfix/./src/cjs/DirectGeometry.js","webpack://three-geometry-hellfix/./src/cjs/Face3.js","webpack://three-geometry-hellfix/./src/cjs/Gmetry.js","webpack://three-geometry-hellfix/./src/cjs/index.js","webpack://three-geometry-hellfix/./src/cjs/mylibrary.js","webpack://three-geometry-hellfix/webpack/bootstrap","webpack://three-geometry-hellfix/./src/cjs/entry.js"],"sourcesContent":["\"use strict\";\n// import { Matrix4, Object3D, Vector2, Vector3 } from \"three\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultFactory = void 0;\nexports.DefaultFactory = {\n    newVector2: function (x, y) { return new window[\"THREE\"].Vector2(x, y); },\n    newVector3: function (x, y, z) { return new window[\"THREE\"].Vector3(x, y, z); },\n    newMatrix3: function () { return new window[\"THREE\"].Matrix3(); },\n    newMatrix4: function () { return new window[\"THREE\"].Matrix4(); },\n    newObject3D: function () { return new window[\"THREE\"].Object3D(); },\n    newBox3: function () { return new window[\"THREE\"].Box3(); },\n    newSphere: function () { return new window[\"THREE\"].Sphere(); },\n    newBufferGeometry: function () { return new window[\"THREE\"].BufferGeometry(); },\n    generateUUID: function () { return window[\"THREE\"].MathUtils.generateUUID(); },\n    newFloat32BufferAttribute: function (array, itemSize, normalized) { return new window[\"THREE\"].Float32BufferAttribute(array, itemSize, normalized); },\n    newColor: function () { return new window[\"THREE\"].Color; },\n    newBufferAttribute: function (array, itemSize, normalized) { return new window[\"THREE\"].BufferAttribute(array, itemSize, normalized); }\n};\n//# sourceMappingURL=DefaultFactory.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.DirectGeometry class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectGeometry = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry = /** @class */ (function () {\n    // class DirectGeometry {\n    function DirectGeometry(factory) {\n        this.vertices = [];\n        this.normals = [];\n        this.colors = [];\n        this.uvs = [];\n        this.uvs2 = [];\n        this.groups = [];\n        this.morphTargets = {};\n        this.skinWeights = [];\n        this.skinIndices = [];\n        // this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.verticesNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        // this.isGeometry = true;\n        this.factory = factory || DefaultFactory_1.DefaultFactory;\n    }\n    DirectGeometry.prototype.computeGroups = function (geometry) {\n        var groups = [];\n        var group, i;\n        var materialIndex = undefined;\n        var faces = geometry.faces;\n        for (i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            // materials\n            if (face.materialIndex !== materialIndex) {\n                materialIndex = face.materialIndex;\n                if (group !== undefined) {\n                    group.count = (i * 3) - group.start;\n                    groups.push(group);\n                }\n                group = {\n                    start: i * 3,\n                    materialIndex: materialIndex\n                };\n            }\n        }\n        if (group !== undefined) {\n            group.count = (i * 3) - group.start;\n            groups.push(group);\n        }\n        this.groups = groups;\n    };\n    DirectGeometry.prototype.fromGeometry = function (geometry) {\n        var faces = geometry.faces;\n        var vertices = geometry.vertices;\n        var faceVertexUvs = geometry.faceVertexUvs;\n        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n        // morphs\n        var morphTargets = geometry.morphTargets;\n        var morphTargetsLength = morphTargets.length;\n        var morphTargetsPosition;\n        if (morphTargetsLength > 0) {\n            morphTargetsPosition = [];\n            for (var i = 0; i < morphTargetsLength; i++) {\n                morphTargetsPosition[i] = {\n                    name: morphTargets[i].name,\n                    data: []\n                };\n            }\n            this.morphTargets.position = morphTargetsPosition;\n        }\n        var morphNormals = geometry.morphNormals;\n        var morphNormalsLength = morphNormals.length;\n        var morphTargetsNormal;\n        if (morphNormalsLength > 0) {\n            morphTargetsNormal = [];\n            for (var i = 0; i < morphNormalsLength; i++) {\n                morphTargetsNormal[i] = {\n                    name: morphNormals[i].name,\n                    data: []\n                };\n            }\n            this.morphTargets.normal = morphTargetsNormal;\n        }\n        // skins\n        var skinIndices = geometry.skinIndices;\n        var skinWeights = geometry.skinWeights;\n        var hasSkinIndices = skinIndices.length === vertices.length;\n        var hasSkinWeights = skinWeights.length === vertices.length;\n        //\n        if (vertices.length > 0 && faces.length === 0) {\n            console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n        }\n        for (var i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n            }\n            else {\n                var normal = face.normal;\n                this.normals.push(normal, normal, normal);\n            }\n            var vertexColors = face.vertexColors;\n            if (vertexColors.length === 3) {\n                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n            }\n            else {\n                var color = face.color;\n                this.colors.push(color, color, color);\n            }\n            if (hasFaceVertexUv === true) {\n                var vertexUvs = faceVertexUvs[0][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n                    // TODO: verify\n                    // this.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n                    this.uvs.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            if (hasFaceVertexUv2 === true) {\n                var vertexUvs = faceVertexUvs[1][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n                    // TODO: verify\n                    // this.uvs2.push( new Vector2(), new Vector2(), new Vector2() ); \n                    this.uvs2.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            // morphs\n            for (var j = 0; j < morphTargetsLength; j++) {\n                var morphTarget = morphTargets[j].vertices;\n                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n            }\n            for (var j = 0; j < morphNormalsLength; j++) {\n                var morphNormal = morphNormals[j].vertexNormals[i];\n                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n            }\n            // skins\n            if (hasSkinIndices) {\n                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n            }\n            if (hasSkinWeights) {\n                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n            }\n        }\n        this.computeGroups(geometry);\n        this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n        this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n        this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n        this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n        this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        return this;\n    };\n    return DirectGeometry;\n}());\nexports.DirectGeometry = DirectGeometry;\n//# sourceMappingURL=DirectGeometry.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Face3 = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar Face3 = /** @class */ (function () {\n    function Face3(a, b, c, normal, color, materialIndex) {\n        if (materialIndex === void 0) { materialIndex = 0; }\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        // this.normal = ( normal && normal.isVector3 ) ? normal : new THREE.Vector3();\n        // this.vertexNormals = Array.isArray( normal ) ? normal : [];\n        // TODO: verify correctness\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new Vector3();\n        // TODO: use DefaultFactory here\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new (window[\"THREE\"]).Vector3();\n        this.normal = (normal && normal.isVector3) ? normal : DefaultFactory_1.DefaultFactory.newVector3();\n        this.vertexNormals = Array.isArray(normal) ? normal : [];\n        // this.color = ( color && color.isColor ) ? color : new THREE.Color();\n        // this.color = ( color && ( color instanceof Color && color.isColor)  ) ? color : new Color(); // TODO: verify correctness\n        // TODO: use DefaultFactory here\n        this.color = (color && color.isColor) ? color : DefaultFactory_1.DefaultFactory.newColor(); // TODO: verify correctness\n        this.vertexColors = Array.isArray(color) ? color : [];\n        this.materialIndex = materialIndex;\n    }\n    Face3.prototype.clone = function () {\n        // TODO: check if new expression is correct\n        // return new this.constructor().copy( this );\n        return new Face3(this.a, this.b, this.c, this.normal.clone(), this.color.clone(), this.materialIndex).copy(this);\n    };\n    Face3.prototype.copy = function (source) {\n        this.a = source.a;\n        this.b = source.b;\n        this.c = source.c;\n        this.normal.copy(source.normal);\n        this.color.copy(source.color);\n        this.materialIndex = source.materialIndex;\n        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n            this.vertexNormals[i] = source.vertexNormals[i].clone();\n        }\n        for (var i = 0, il = source.vertexColors.length; i < il; i++) {\n            this.vertexColors[i] = source.vertexColors[i].clone();\n        }\n        return this;\n    };\n    return Face3;\n}());\nexports.Face3 = Face3;\n//# sourceMappingURL=Face3.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Gmetry = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\n// const _m1 = new Matrix4();\n// const _obj = new Object3D();\n// const _offset = new Vector3();\n// class Geometry extends EventDispatcher {\nvar Gmetry = /** @class */ (function () {\n    function Gmetry(factory) {\n        // super();\n        // this.uuid = MathUtils.generateUUID();\n        this.name = '';\n        this.type = 'Geometry';\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.elementsNeedUpdate = false;\n        this.verticesNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.lineDistancesNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        this.isGeometry = true;\n        this.factory = factory || DefaultFactory_1.DefaultFactory;\n        this.uuid = this.factory.generateUUID();\n        this._m1 = this.factory.newMatrix4();\n        this._obj = this.factory.newObject3D();\n        this._offset = this.factory.newVector3();\n    }\n    Gmetry.prototype.applyMatrix4 = function (matrix) {\n        // TODO: verify\n        // const normalMatrix = new Matrix3().getNormalMatrix( matrix );\n        var normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var vertex = this.vertices[i];\n            vertex.applyMatrix4(matrix);\n        }\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.normal.applyMatrix3(normalMatrix).normalize();\n            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n            }\n        }\n        if (this.boundingBox !== null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere !== null) {\n            this.computeBoundingSphere();\n        }\n        this.verticesNeedUpdate = true;\n        this.normalsNeedUpdate = true;\n        return this;\n    };\n    Gmetry.prototype.rotateX = function (angle) {\n        // rotate geometry around world x-axis\n        this._m1.makeRotationX(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.rotateY = function (angle) {\n        // rotate geometry around world y-axis\n        this._m1.makeRotationY(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.rotateZ = function (angle) {\n        // rotate geometry around world z-axis\n        this._m1.makeRotationZ(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.translate = function (x, y, z) {\n        // translate geometry\n        this._m1.makeTranslation(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.scale = function (x, y, z) {\n        // scale geometry\n        this._m1.makeScale(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.lookAt = function (vector) {\n        this._obj.lookAt(vector);\n        this._obj.updateMatrix();\n        this.applyMatrix4(this._obj.matrix);\n        return this;\n    };\n    Gmetry.prototype.fromBufferGeometry = function (geometry) {\n        var scope = this;\n        var index = geometry.index !== null ? geometry.index : undefined;\n        var attributes = geometry.attributes;\n        if (attributes.position === undefined) {\n            console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n            return this;\n        }\n        var position = attributes.position;\n        var normal = attributes.normal;\n        var color = attributes.color;\n        var uv = attributes.uv;\n        var uv2 = attributes.uv2;\n        if (uv2 !== undefined)\n            this.faceVertexUvs[1] = [];\n        for (var i = 0; i < position.count; i++) {\n            // TODO: verify\n            // scope.vertices.push( new Vector3().fromBufferAttribute( position, i ) );\n            scope.vertices.push(this.factory.newVector3().fromBufferAttribute(position, i));\n            if (color !== undefined) {\n                // TODO: verify\n                // scope.colors.push( new Color().fromBufferAttribute( color, i ) ); \n                scope.colors.push(this.factory.newColor().fromBufferAttribute(color, i));\n            }\n        }\n        var factory = this.factory;\n        // TODO: put to helper functions\n        function addFace(a, b, c, materialIndex) {\n            var vertexColors = (color === undefined) ? [] : [\n                scope.colors[a].clone(),\n                scope.colors[b].clone(),\n                scope.colors[c].clone()\n            ];\n            var vertexNormals = (normal === undefined) ? [] : [\n                // TODO: verify\n                // new Vector3().fromBufferAttribute( normal, a ),\n                // new Vector3().fromBufferAttribute( normal, b ),\n                // new Vector3().fromBufferAttribute( normal, c )\n                factory.newVector3().fromBufferAttribute(normal, a),\n                factory.newVector3().fromBufferAttribute(normal, b),\n                factory.newVector3().fromBufferAttribute(normal, c)\n            ];\n            var face = new Face3_1.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n            scope.faces.push(face);\n            if (uv !== undefined) {\n                scope.faceVertexUvs[0].push([\n                    // TODO: verify\n                    // new Vector2().fromBufferAttribute( uv, a ),\n                    // new Vector2().fromBufferAttribute( uv, b ),\n                    // new Vector2().fromBufferAttribute( uv, c )\n                    factory.newVector2().fromBufferAttribute(uv, a),\n                    factory.newVector2().fromBufferAttribute(uv, b),\n                    factory.newVector2().fromBufferAttribute(uv, c)\n                ]);\n            }\n            if (uv2 !== undefined) {\n                scope.faceVertexUvs[1].push([\n                    // TODO: verify\n                    // new Vector2().fromBufferAttribute( uv2, a ),\n                    // new Vector2().fromBufferAttribute( uv2, b ),\n                    // new Vector2().fromBufferAttribute( uv2, c )\n                    factory.newVector2().fromBufferAttribute(uv2, a),\n                    factory.newVector2().fromBufferAttribute(uv2, b),\n                    factory.newVector2().fromBufferAttribute(uv2, c)\n                ]);\n            }\n        }\n        var groups = geometry.groups;\n        if (groups.length > 0) {\n            for (var i = 0; i < groups.length; i++) {\n                var group = groups[i];\n                var start = group.start;\n                var count = group.count;\n                for (var j = start, jl = start + count; j < jl; j += 3) {\n                    if (index !== undefined) {\n                        addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n                    }\n                    else {\n                        addFace(j, j + 1, j + 2, group.materialIndex);\n                    }\n                }\n            }\n        }\n        else {\n            if (index !== undefined) {\n                for (var i = 0; i < index.count; i += 3) {\n                    addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n                }\n            }\n            else {\n                for (var i = 0; i < position.count; i += 3) {\n                    addFace(i, i + 1, i + 2);\n                }\n            }\n        }\n        this.computeFaceNormals();\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        return this;\n    };\n    Gmetry.prototype.center = function () {\n        this.computeBoundingBox();\n        this.boundingBox.getCenter(this._offset).negate();\n        this.translate(this._offset.x, this._offset.y, this._offset.z);\n        return this;\n    };\n    Gmetry.prototype.normalize = function () {\n        this.computeBoundingSphere();\n        var center = this.boundingSphere.center;\n        var radius = this.boundingSphere.radius;\n        var s = radius === 0 ? 1 : 1.0 / radius;\n        // TODO: verify\n        // const matrix = new Matrix4();\n        var matrix = this.factory.newMatrix4();\n        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n        this.applyMatrix4(matrix);\n        return this;\n    };\n    Gmetry.prototype.computeFaceNormals = function () {\n        // TODO: verify\n        // const cb = new Vector3(), ab = new Vector3();\n        var cb = this.factory.newVector3(), ab = this.factory.newVector3();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vA = this.vertices[face.a];\n            var vB = this.vertices[face.b];\n            var vC = this.vertices[face.c];\n            cb.subVectors(vC, vB);\n            ab.subVectors(vA, vB);\n            cb.cross(ab);\n            cb.normalize();\n            face.normal.copy(cb);\n        }\n    };\n    Gmetry.prototype.computeVertexNormals = function (areaWeighted) {\n        if (areaWeighted === void 0) { areaWeighted = true; }\n        var vertices = new Array(this.vertices.length);\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            // TODO: verify\n            // vertices[ v ] = new Vector3(); \n            vertices[v] = this.factory.newVector3();\n        }\n        if (areaWeighted) {\n            // vertex normals weighted by triangle areas\n            // http://www.iquilezles.org/www/articles/normals/normals.htm\n            // TODO: verify\n            // const cb = new Vector3(), ab = new Vector3(); \n            var cb = this.factory.newVector3(), ab = this.factory.newVector3();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var vA = this.vertices[face.a];\n                var vB = this.vertices[face.b];\n                var vC = this.vertices[face.c];\n                cb.subVectors(vC, vB);\n                ab.subVectors(vA, vB);\n                cb.cross(ab);\n                vertices[face.a].add(cb);\n                vertices[face.b].add(cb);\n                vertices[face.c].add(cb);\n            }\n        }\n        else {\n            this.computeFaceNormals();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                vertices[face.a].add(face.normal);\n                vertices[face.b].add(face.normal);\n                vertices[face.c].add(face.normal);\n            }\n        }\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            vertices[v].normalize();\n        }\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(vertices[face.a]);\n                vertexNormals[1].copy(vertices[face.b]);\n                vertexNormals[2].copy(vertices[face.c]);\n            }\n            else {\n                vertexNormals[0] = vertices[face.a].clone();\n                vertexNormals[1] = vertices[face.b].clone();\n                vertexNormals[2] = vertices[face.c].clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeFlatVertexNormals = function () {\n        this.computeFaceNormals();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(face.normal);\n                vertexNormals[1].copy(face.normal);\n                vertexNormals[2].copy(face.normal);\n            }\n            else {\n                vertexNormals[0] = face.normal.clone();\n                vertexNormals[1] = face.normal.clone();\n                vertexNormals[2] = face.normal.clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeMorphNormals = function () {\n        // save original normals\n        // - create temp variables on first access\n        //   otherwise just copy (for faster repeated calls)\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            if (!face.__originalFaceNormal) {\n                face.__originalFaceNormal = face.normal.clone();\n            }\n            else {\n                face.__originalFaceNormal.copy(face.normal);\n            }\n            if (!face.__originalVertexNormals)\n                face.__originalVertexNormals = [];\n            for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n                if (!face.__originalVertexNormals[i]) {\n                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n                }\n                else {\n                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n                }\n            }\n        }\n        // use temp geometry to compute face and vertex normals for each morph\n        // const tmpGeo = new Geometry(); // BEFORE\n        var tmpGeo = new Gmetry(this.factory);\n        tmpGeo.faces = this.faces;\n        for (var i = 0, il = this.morphTargets.length; i < il; i++) {\n            // create on first access\n            if (!this.morphNormals[i]) {\n                this.morphNormals[i] = {}; // TODO: check\n                this.morphNormals[i].faceNormals = [];\n                this.morphNormals[i].vertexNormals = [];\n                var dstNormalsFace = this.morphNormals[i].faceNormals;\n                var dstNormalsVertex = this.morphNormals[i].vertexNormals;\n                for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                    // TODO: vertify\n                    // const faceNormal = new Vector3(); \n                    var faceNormal = this.factory.newVector3();\n                    // const vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() }; \n                    var vertexNormals = { a: this.factory.newVector3(), b: this.factory.newVector3(), c: this.factory.newVector3() };\n                    dstNormalsFace.push(faceNormal);\n                    dstNormalsVertex.push(vertexNormals);\n                }\n            }\n            var morphNormals = this.morphNormals[i];\n            // set vertices to morph target\n            tmpGeo.vertices = this.morphTargets[i].vertices;\n            // compute morph normals\n            tmpGeo.computeFaceNormals();\n            tmpGeo.computeVertexNormals();\n            // store morph normals\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var faceNormal = morphNormals.faceNormals[f];\n                var vertexNormals = morphNormals.vertexNormals[f];\n                faceNormal.copy(face.normal);\n                vertexNormals.a.copy(face.vertexNormals[0]);\n                vertexNormals.b.copy(face.vertexNormals[1]);\n                vertexNormals.c.copy(face.vertexNormals[2]);\n            }\n        }\n        // restore original normals\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            face.normal = face.__originalFaceNormal;\n            face.vertexNormals = face.__originalVertexNormals;\n        }\n    };\n    Gmetry.prototype.computeBoundingBox = function () {\n        if (this.boundingBox === null) {\n            // TODO: verify\n            // this.boundingBox = new Box3();\n            this.boundingBox = this.factory.newBox3();\n        }\n        this.boundingBox.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.computeBoundingSphere = function () {\n        if (this.boundingSphere === null) {\n            // TODO: verify\n            // this.boundingSphere = new Sphere();\n            this.boundingSphere = this.factory.newSphere();\n        }\n        this.boundingSphere.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.merge = function (geometry, matrix, materialIndexOffset) {\n        if (materialIndexOffset === void 0) { materialIndexOffset = 0; }\n        if (!(geometry && geometry.isGeometry)) {\n            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n            return;\n        }\n        var normalMatrix;\n        var vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\n        if (matrix !== undefined) {\n            // TODO: verify\n            // normalMatrix = new Matrix3().getNormalMatrix( matrix ); \n            normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        }\n        // vertices\n        for (var i = 0, il = vertices2.length; i < il; i++) {\n            var vertex = vertices2[i];\n            var vertexCopy = vertex.clone();\n            if (matrix !== undefined)\n                vertexCopy.applyMatrix4(matrix);\n            vertices1.push(vertexCopy);\n        }\n        // colors\n        for (var i = 0, il = colors2.length; i < il; i++) {\n            colors1.push(colors2[i].clone());\n        }\n        // faces\n        for (var i = 0, il = faces2.length; i < il; i++) {\n            var face = faces2[i];\n            var normal = void 0, color = void 0;\n            var faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n            var faceCopy = new Face3_1.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n            faceCopy.normal.copy(face.normal);\n            if (normalMatrix !== undefined) {\n                faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n            }\n            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n                normal = faceVertexNormals[j].clone();\n                if (normalMatrix !== undefined) {\n                    normal.applyMatrix3(normalMatrix).normalize();\n                }\n                faceCopy.vertexNormals.push(normal);\n            }\n            faceCopy.color.copy(face.color);\n            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\n                color = faceVertexColors[j];\n                faceCopy.vertexColors.push(color.clone());\n            }\n            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n            faces1.push(faceCopy);\n        }\n        // uvs\n        for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs2 = geometry.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined)\n                this.faceVertexUvs[i] = [];\n            for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n                var uvs2 = faceVertexUvs2[j], uvsCopy = [];\n                for (var k = 0, kl = uvs2.length; k < kl; k++) {\n                    uvsCopy.push(uvs2[k].clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n    };\n    Gmetry.prototype.mergeMesh = function (mesh) {\n        if (!(mesh && mesh.isMesh)) {\n            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n            return;\n        }\n        if (mesh.matrixAutoUpdate)\n            mesh.updateMatrix();\n        this.merge(mesh.geometry, mesh.matrix);\n    };\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n    Gmetry.prototype.mergeVertices = function (precisionPoints) {\n        if (precisionPoints === void 0) { precisionPoints = 4; }\n        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        var unique = [], changes = [];\n        var precision = Math.pow(10, precisionPoints);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var v = this.vertices[i];\n            var key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\n            if (verticesMap[key] === undefined) {\n                verticesMap[key] = i;\n                unique.push(this.vertices[i]);\n                changes[i] = unique.length - 1;\n            }\n            else {\n                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n                changes[i] = changes[verticesMap[key]];\n            }\n        }\n        // if faces are completely degenerate after merging vertices, we\n        // have to remove them from the geometry.\n        var faceIndicesToRemove = [];\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.a = changes[face.a];\n            face.b = changes[face.b];\n            face.c = changes[face.c];\n            var indices = [face.a, face.b, face.c];\n            // if any duplicate vertices are found in a Face3\n            // we have to remove the face as nothing can be saved\n            for (var n = 0; n < 3; n++) {\n                if (indices[n] === indices[(n + 1) % 3]) {\n                    faceIndicesToRemove.push(i);\n                    break;\n                }\n            }\n        }\n        for (var i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n            var idx = faceIndicesToRemove[i];\n            this.faces.splice(idx, 1);\n            for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n                this.faceVertexUvs[j].splice(idx, 1);\n            }\n        }\n        // Use unique set of vertices\n        var diff = this.vertices.length - unique.length;\n        this.vertices = unique;\n        return diff;\n    };\n    Gmetry.prototype.setFromPoints = function (points) {\n        this.vertices = [];\n        for (var i = 0, l = points.length; i < l; i++) {\n            var point = points[i];\n            // TODO: verify\n            // this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n            this.vertices.push(this.factory.newVector3(point.x, point.y, point.z || 0));\n        }\n        return this;\n    };\n    Gmetry.prototype.sortFacesByMaterialIndex = function () {\n        var faces = this.faces;\n        var length = faces.length;\n        // tag faces\n        for (var i = 0; i < length; i++) {\n            faces[i]._id = i;\n        }\n        // sort faces\n        function materialIndexSort(a, b) {\n            return a.materialIndex - b.materialIndex;\n        }\n        faces.sort(materialIndexSort);\n        // sort uvs\n        var uvs1 = this.faceVertexUvs[0];\n        var uvs2 = this.faceVertexUvs[1];\n        var newUvs1, newUvs2;\n        if (uvs1 && uvs1.length === length)\n            newUvs1 = [];\n        if (uvs2 && uvs2.length === length)\n            newUvs2 = [];\n        for (var i = 0; i < length; i++) {\n            var id = faces[i]._id;\n            if (newUvs1)\n                newUvs1.push(uvs1[id]);\n            if (newUvs2)\n                newUvs2.push(uvs2[id]);\n        }\n        if (newUvs1)\n            this.faceVertexUvs[0] = newUvs1;\n        if (newUvs2)\n            this.faceVertexUvs[1] = newUvs2;\n    };\n    Gmetry.prototype.toJSON = function () {\n        var data = {\n            metadata: {\n                version: 4.5,\n                type: 'Geometry',\n                generator: 'Geometry.toJSON'\n            },\n            // TODO: check\n            uuid: null,\n            type: null,\n            name: null,\n            data: null\n        };\n        // standard Geometry serialization\n        data.uuid = this.uuid;\n        data.type = this.type;\n        if (this.name !== '')\n            data.name = this.name;\n        if (this.parameters !== undefined) {\n            var parameters = this.parameters;\n            for (var key in parameters) {\n                if (parameters[key] !== undefined)\n                    data[key] = parameters[key];\n            }\n            return data;\n        }\n        var vertices = [];\n        for (var i = 0; i < this.vertices.length; i++) {\n            var vertex = this.vertices[i];\n            vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n        var faces = [];\n        var normals = [];\n        var normalsHash = {};\n        var colors = [];\n        var colorsHash = {};\n        var uvs = [];\n        var uvsHash = {};\n        for (var i = 0; i < this.faces.length; i++) {\n            var face = this.faces[i];\n            var hasMaterial = true;\n            var hasFaceUv = false; // deprecated\n            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n            var hasFaceNormal = face.normal.length() > 0;\n            var hasFaceVertexNormal = face.vertexNormals.length > 0;\n            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n            var hasFaceVertexColor = face.vertexColors.length > 0;\n            var faceType = 0;\n            faceType = setBit(faceType, 0, 0); // isQuad\n            faceType = setBit(faceType, 1, hasMaterial);\n            faceType = setBit(faceType, 2, hasFaceUv);\n            faceType = setBit(faceType, 3, hasFaceVertexUv);\n            faceType = setBit(faceType, 4, hasFaceNormal);\n            faceType = setBit(faceType, 5, hasFaceVertexNormal);\n            faceType = setBit(faceType, 6, hasFaceColor);\n            faceType = setBit(faceType, 7, hasFaceVertexColor);\n            faces.push(faceType);\n            faces.push(face.a, face.b, face.c);\n            faces.push(face.materialIndex);\n            if (hasFaceVertexUv) {\n                var faceVertexUvs = this.faceVertexUvs[0][i];\n                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n            }\n            if (hasFaceNormal) {\n                faces.push(getNormalIndex(face.normal));\n            }\n            if (hasFaceVertexNormal) {\n                var vertexNormals = face.vertexNormals;\n                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n            }\n            if (hasFaceColor) {\n                faces.push(getColorIndex(face.color));\n            }\n            if (hasFaceVertexColor) {\n                var vertexColors = face.vertexColors;\n                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n            }\n        }\n        function setBit(value, position, enabled) {\n            return enabled ? value | (1 << position) : value & (~(1 << position));\n        }\n        function getNormalIndex(normal) {\n            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n            if (normalsHash[hash] !== undefined) {\n                return normalsHash[hash];\n            }\n            normalsHash[hash] = normals.length / 3;\n            normals.push(normal.x, normal.y, normal.z);\n            return normalsHash[hash];\n        }\n        function getColorIndex(color) {\n            var hash = color.r.toString() + color.g.toString() + color.b.toString();\n            if (colorsHash[hash] !== undefined) {\n                return colorsHash[hash];\n            }\n            colorsHash[hash] = colors.length;\n            colors.push(color.getHex());\n            return colorsHash[hash];\n        }\n        function getUvIndex(uv) {\n            var hash = uv.x.toString() + uv.y.toString();\n            if (uvsHash[hash] !== undefined) {\n                return uvsHash[hash];\n            }\n            uvsHash[hash] = uvs.length / 2;\n            uvs.push(uv.x, uv.y);\n            return uvsHash[hash];\n        }\n        data.data = {};\n        data.data.vertices = vertices;\n        data.data.normals = normals;\n        if (colors.length > 0)\n            data.data.colors = colors;\n        if (uvs.length > 0)\n            data.data.uvs = [uvs]; // temporal backward compatibility\n        data.data.faces = faces;\n        return data;\n    };\n    Gmetry.prototype.clone = function () {\n        /*\n         // Handle primitives\n\n         const parameters = this.parameters;\n\n         if ( parameters !== undefined ) {\n\n         const values = [];\n\n         for ( const key in parameters ) {\n\n         values.push( parameters[ key ] );\n\n         }\n\n         const geometry = Object.create( this.constructor.prototype );\n         this.constructor.apply( geometry, values );\n         return geometry;\n\n         }\n\n         return new this.constructor().copy( this );\n         */\n        // return new Geometry().copy( this ); // BEFORE\n        return new Gmetry(this.factory).copy(this);\n    };\n    Gmetry.prototype.copy = function (source) {\n        // reset\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // name\n        this.name = source.name;\n        // vertices\n        var vertices = source.vertices;\n        for (var i = 0, il = vertices.length; i < il; i++) {\n            this.vertices.push(vertices[i].clone());\n        }\n        // colors\n        var colors = source.colors;\n        for (var i = 0, il = colors.length; i < il; i++) {\n            this.colors.push(colors[i].clone());\n        }\n        // faces\n        var faces = source.faces;\n        for (var i = 0, il = faces.length; i < il; i++) {\n            this.faces.push(faces[i].clone());\n        }\n        // face vertex uvs\n        for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs = source.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n                var uvs = faceVertexUvs[j], uvsCopy = [];\n                for (var k = 0, kl = uvs.length; k < kl; k++) {\n                    var uv = uvs[k];\n                    uvsCopy.push(uv.clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n        // morph targets\n        var morphTargets = source.morphTargets;\n        for (var i = 0, il = morphTargets.length; i < il; i++) {\n            var morphTarget = {}; // // TODO: check\n            morphTarget.name = morphTargets[i].name;\n            // vertices\n            if (morphTargets[i].vertices !== undefined) {\n                morphTarget.vertices = [];\n                for (var j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n                    morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n                }\n            }\n            // normals\n            if (morphTargets[i].normals !== undefined) {\n                morphTarget.normals = [];\n                for (var j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n                    morphTarget.normals.push(morphTargets[i].normals[j].clone());\n                }\n            }\n            this.morphTargets.push(morphTarget);\n        }\n        // morph normals\n        var morphNormals = source.morphNormals;\n        for (var i = 0, il = morphNormals.length; i < il; i++) {\n            var morphNormal = {}; // TODO: check\n            // vertex normals\n            if (morphNormals[i].vertexNormals !== undefined) {\n                morphNormal.vertexNormals = [];\n                for (var j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n                    var srcVertexNormal = morphNormals[i].vertexNormals[j];\n                    // TODO: add type\n                    var destVertexNormal = { a: null, b: null, c: null }; // TODO: check\n                    destVertexNormal.a = srcVertexNormal.a.clone();\n                    destVertexNormal.b = srcVertexNormal.b.clone();\n                    destVertexNormal.c = srcVertexNormal.c.clone();\n                    morphNormal.vertexNormals.push(destVertexNormal);\n                }\n            }\n            // face normals\n            if (morphNormals[i].faceNormals !== undefined) {\n                morphNormal.faceNormals = [];\n                for (var j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n                    morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n                }\n            }\n            this.morphNormals.push(morphNormal);\n        }\n        // skin weights\n        var skinWeights = source.skinWeights;\n        for (var i = 0, il = skinWeights.length; i < il; i++) {\n            this.skinWeights.push(skinWeights[i].clone());\n        }\n        // skin indices\n        var skinIndices = source.skinIndices;\n        for (var i = 0, il = skinIndices.length; i < il; i++) {\n            this.skinIndices.push(skinIndices[i].clone());\n        }\n        // line distances\n        var lineDistances = source.lineDistances;\n        for (var i = 0, il = lineDistances.length; i < il; i++) {\n            this.lineDistances.push(lineDistances[i]);\n        }\n        // bounding box\n        var boundingBox = source.boundingBox;\n        if (boundingBox !== null) {\n            this.boundingBox = boundingBox.clone();\n        }\n        // bounding sphere\n        var boundingSphere = source.boundingSphere;\n        if (boundingSphere !== null) {\n            this.boundingSphere = boundingSphere.clone();\n        }\n        // update flags\n        this.elementsNeedUpdate = source.elementsNeedUpdate;\n        this.verticesNeedUpdate = source.verticesNeedUpdate;\n        this.uvsNeedUpdate = source.uvsNeedUpdate;\n        this.normalsNeedUpdate = source.normalsNeedUpdate;\n        this.colorsNeedUpdate = source.colorsNeedUpdate;\n        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n        this.groupsNeedUpdate = source.groupsNeedUpdate;\n        return this;\n    };\n    Gmetry.prototype.toBufferGeometry = function () {\n        var geometry = new DirectGeometry_1.DirectGeometry(this.factory).fromGeometry(this);\n        // TODO: verify\n        // const buffergeometry = new BufferGeometry();\n        var buffergeometry = this.factory.newBufferGeometry();\n        var positions = new Float32Array(geometry.vertices.length * 3);\n        // TODO: verfify\n        // buffergeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n        buffergeometry.setAttribute('position', this.factory.newBufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n        if (geometry.normals.length > 0) {\n            var normals = new Float32Array(geometry.normals.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n            buffergeometry.setAttribute('normal', this.factory.newBufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n        }\n        if (geometry.colors.length > 0) {\n            var colors = new Float32Array(geometry.colors.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n            buffergeometry.setAttribute('color', this.factory.newBufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n        }\n        if (geometry.uvs.length > 0) {\n            var uvs = new Float32Array(geometry.uvs.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n            buffergeometry.setAttribute('uv', this.factory.newBufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n        }\n        if (geometry.uvs2.length > 0) {\n            var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n            buffergeometry.setAttribute('uv2', this.factory.newBufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n        }\n        // groups\n        buffergeometry.groups = geometry.groups;\n        // morphs\n        for (var name_1 in geometry.morphTargets) {\n            var array = [];\n            var morphTargets = geometry.morphTargets[name_1];\n            for (var i = 0, l = morphTargets.length; i < l; i++) {\n                var morphTarget = morphTargets[i];\n                // TODO: verify\n                // const attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n                var attribute = this.factory.newFloat32BufferAttribute(morphTarget.data.length * 3, 3);\n                attribute.name = morphTarget.name;\n                array.push(attribute.copyVector3sArray(morphTarget.data));\n            }\n            buffergeometry.morphAttributes[name_1] = array;\n        }\n        // skinning\n        if (geometry.skinIndices.length > 0) {\n            // TODO: verify\n            // const skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 ); \n            var skinIndices = this.factory.newFloat32BufferAttribute(geometry.skinIndices.length * 4, 4);\n            buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n        }\n        if (geometry.skinWeights.length > 0) {\n            // TODO: verify\n            // const skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n            var skinWeights = this.factory.newFloat32BufferAttribute(geometry.skinWeights.length * 4, 4);\n            buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n        }\n        //\n        if (geometry.boundingSphere !== null) {\n            buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            buffergeometry.boundingBox = geometry.boundingBox.clone();\n        }\n        return buffergeometry;\n    };\n    Gmetry.prototype.computeTangents = function () {\n        console.error('THREE.Geometry: .computeTangents() has been removed.');\n    };\n    Gmetry.prototype.computeLineDistances = function () {\n        console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n    };\n    Gmetry.prototype.applyMatrix = function (matrix) {\n        console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n        return this.applyMatrix4(matrix);\n    };\n    Gmetry.prototype.dispose = function () {\n        // This is not required when used outside of THREE.\n        // this.dispatchEvent( { type: 'dispose' } );\n    };\n    Gmetry.createBufferGeometryFromObject = function (object, factory) {\n        var fact = factory || DefaultFactory_1.DefaultFactory;\n        // TODO: verify\n        // let buffergeometry = new BufferGeometry();\n        var buffergeometry = fact.newBufferGeometry();\n        var geometry = object.geometry;\n        if (object.isPoints || object.isLine) {\n            // TODO: verify\n            // const positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n            // const colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n            var positions = fact.newFloat32BufferAttribute(geometry.vertices.length * 3, 3);\n            var colors = fact.newFloat32BufferAttribute(geometry.colors.length * 3, 3);\n            buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n            buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n                // TODO: verify\n                // const lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n                var lineDistances = fact.newFloat32BufferAttribute(geometry.lineDistances.length, 1);\n                buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n            }\n            if (geometry.boundingSphere !== null) {\n                buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n            }\n            if (geometry.boundingBox !== null) {\n                buffergeometry.boundingBox = geometry.boundingBox.clone();\n            }\n        }\n        else if (object.isMesh) {\n            buffergeometry = geometry.toBufferGeometry();\n        }\n        return buffergeometry;\n    };\n    return Gmetry;\n}());\nexports.Gmetry = Gmetry;\n// Geometry.prototype.isGeometry = true;\n// class DirectGeometry {\n// \tconstructor() {\n// \t\tthis.vertices = [];\n// \t\tthis.normals = [];\n// \t\tthis.colors = [];\n// \t\tthis.uvs = [];\n// \t\tthis.uvs2 = [];\n// \t\tthis.groups = [];\n// \t\tthis.morphTargets = {};\n// \t\tthis.skinWeights = [];\n// \t\tthis.skinIndices = [];\n// \t\t// this.lineDistances = [];\n// \t\tthis.boundingBox = null;\n// \t\tthis.boundingSphere = null;\n// \t\t// update flags\n// \t\tthis.verticesNeedUpdate = false;\n// \t\tthis.normalsNeedUpdate = false;\n// \t\tthis.colorsNeedUpdate = false;\n// \t\tthis.uvsNeedUpdate = false;\n// \t\tthis.groupsNeedUpdate = false;\n// \t\tthis.isGeometry = true;\n// \t}\n// \tcomputeGroups( geometry ) {\n// \t\tconst groups = [];\n// \t\tlet group, i;\n// \t\tlet materialIndex = undefined;\n// \t\tconst faces = geometry.faces;\n// \t\tfor ( i = 0; i < faces.length; i ++ ) {\n// \t\t\tconst face = faces[ i ];\n// \t\t\t// materials\n// \t\t\tif ( face.materialIndex !== materialIndex ) {\n// \t\t\t\tmaterialIndex = face.materialIndex;\n// \t\t\t\tif ( group !== undefined ) {\n// \t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n// \t\t\t\t\tgroups.push( group );\n// \t\t\t\t}\n// \t\t\t\tgroup = {\n// \t\t\t\t\tstart: i * 3,\n// \t\t\t\t\tmaterialIndex: materialIndex\n// \t\t\t\t};\n// \t\t\t}\n// \t\t}\n// \t\tif ( group !== undefined ) {\n// \t\t\tgroup.count = ( i * 3 ) - group.start;\n// \t\t\tgroups.push( group );\n// \t\t}\n// \t\tthis.groups = groups;\n// \t}\n// \tfromGeometry( geometry ) {\n// \t\tconst faces = geometry.faces;\n// \t\tconst vertices = geometry.vertices;\n// \t\tconst faceVertexUvs = geometry.faceVertexUvs;\n// \t\tconst hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n// \t\tconst hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n// \t\t// morphs\n// \t\tconst morphTargets = geometry.morphTargets;\n// \t\tconst morphTargetsLength = morphTargets.length;\n// \t\tlet morphTargetsPosition;\n// \t\tif ( morphTargetsLength > 0 ) {\n// \t\t\tmorphTargetsPosition = [];\n// \t\t\tfor ( let i = 0; i < morphTargetsLength; i ++ ) {\n// \t\t\t\tmorphTargetsPosition[ i ] = {\n// \t\t\t\t\tname: morphTargets[ i ].name,\n// \t\t\t\t \tdata: []\n// \t\t\t\t};\n// \t\t\t}\n// \t\t\tthis.morphTargets.position = morphTargetsPosition;\n// \t\t}\n// \t\tconst morphNormals = geometry.morphNormals;\n// \t\tconst morphNormalsLength = morphNormals.length;\n// \t\tlet morphTargetsNormal;\n// \t\tif ( morphNormalsLength > 0 ) {\n// \t\t\tmorphTargetsNormal = [];\n// \t\t\tfor ( let i = 0; i < morphNormalsLength; i ++ ) {\n// \t\t\t\tmorphTargetsNormal[ i ] = {\n// \t\t\t\t\tname: morphNormals[ i ].name,\n// \t\t\t\t \tdata: []\n// \t\t\t\t};\n// \t\t\t}\n// \t\t\tthis.morphTargets.normal = morphTargetsNormal;\n// \t\t}\n// \t\t// skins\n// \t\tconst skinIndices = geometry.skinIndices;\n// \t\tconst skinWeights = geometry.skinWeights;\n// \t\tconst hasSkinIndices = skinIndices.length === vertices.length;\n// \t\tconst hasSkinWeights = skinWeights.length === vertices.length;\n// \t\t//\n// \t\tif ( vertices.length > 0 && faces.length === 0 ) {\n// \t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n// \t\t}\n// \t\tfor ( let i = 0; i < faces.length; i ++ ) {\n// \t\t\tconst face = faces[ i ];\n// \t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n// \t\t\tconst vertexNormals = face.vertexNormals;\n// \t\t\tif ( vertexNormals.length === 3 ) {\n// \t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n// \t\t\t} else {\n// \t\t\t\tconst normal = face.normal;\n// \t\t\t\tthis.normals.push( normal, normal, normal );\n// \t\t\t}\n// \t\t\tconst vertexColors = face.vertexColors;\n// \t\t\tif ( vertexColors.length === 3 ) {\n// \t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n// \t\t\t} else {\n// \t\t\t\tconst color = face.color;\n// \t\t\t\tthis.colors.push( color, color, color );\n// \t\t\t}\n// \t\t\tif ( hasFaceVertexUv === true ) {\n// \t\t\t\tconst vertexUvs = faceVertexUvs[ 0 ][ i ];\n// \t\t\t\tif ( vertexUvs !== undefined ) {\n// \t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n// \t\t\t\t} else {\n// \t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n// \t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif ( hasFaceVertexUv2 === true ) {\n// \t\t\t\tconst vertexUvs = faceVertexUvs[ 1 ][ i ];\n// \t\t\t\tif ( vertexUvs !== undefined ) {\n// \t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n// \t\t\t\t} else {\n// \t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n// \t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// morphs\n// \t\t\tfor ( let j = 0; j < morphTargetsLength; j ++ ) {\n// \t\t\t\tconst morphTarget = morphTargets[ j ].vertices;\n// \t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n// \t\t\t}\n// \t\t\tfor ( let j = 0; j < morphNormalsLength; j ++ ) {\n// \t\t\t\tconst morphNormal = morphNormals[ j ].vertexNormals[ i ];\n// \t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n// \t\t\t}\n// \t\t\t// skins\n// \t\t\tif ( hasSkinIndices ) {\n// \t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n// \t\t\t}\n// \t\t\tif ( hasSkinWeights ) {\n// \t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n// \t\t\t}\n// \t\t}\n// \t\tthis.computeGroups( geometry );\n// \t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n// \t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n// \t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n// \t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n// \t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n// \t\tif ( geometry.boundingSphere !== null ) {\n// \t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n// \t\t}\n// \t\tif ( geometry.boundingBox !== null ) {\n// \t\t\tthis.boundingBox = geometry.boundingBox.clone();\n// \t\t}\n// \t\treturn this;\n// \t}\n// }\n// class Face3 {\n// \tconstructor( a, b, c, normal, color, materialIndex = 0 ) {\n// \t\tthis.a = a;\n// \t\tthis.b = b;\n// \t\tthis.c = c;\n// \t\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n// \t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n// \t\tthis.color = ( color && color.isColor ) ? color : new Color();\n// \t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n// \t\tthis.materialIndex = materialIndex;\n// \t}\n// \tclone() {\n// \t\treturn new this.constructor().copy( this );\n// \t}\n// \tcopy( source ) {\n// \t\tthis.a = source.a;\n// \t\tthis.b = source.b;\n// \t\tthis.c = source.c;\n// \t\tthis.normal.copy( source.normal );\n// \t\tthis.color.copy( source.color );\n// \t\tthis.materialIndex = source.materialIndex;\n// \t\tfor ( let i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n// \t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n// \t\t}\n// \t\tfor ( let i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n// \t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n// \t\t}\n// \t\treturn this;\n// \t}\n// }\n// export { Face3, Gmetry };\n//# sourceMappingURL=Gmetry.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeGeometryHellfix = exports.Gmetry = exports.Face3 = exports.DirectGeometry = void 0;\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nObject.defineProperty(exports, \"DirectGeometry\", { enumerable: true, get: function () { return DirectGeometry_1.DirectGeometry; } });\nvar Face3_1 = require(\"./Face3\");\nObject.defineProperty(exports, \"Face3\", { enumerable: true, get: function () { return Face3_1.Face3; } });\nvar Gmetry_1 = require(\"./Gmetry\");\nObject.defineProperty(exports, \"Gmetry\", { enumerable: true, get: function () { return Gmetry_1.Gmetry; } });\nvar mylibrary_1 = require(\"./mylibrary\");\nObject.defineProperty(exports, \"ThreeGeometryHellfix\", { enumerable: true, get: function () { return mylibrary_1.ThreeGeometryHellfix; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeGeometryHellfix = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\nvar Gmetry_1 = require(\"./Gmetry\");\nexports.ThreeGeometryHellfix = {\n    DirectGeometry: DirectGeometry_1.DirectGeometry,\n    Face3: Face3_1.Face3,\n    Gmetry: Gmetry_1.Gmetry,\n    DefaultFactory: DefaultFactory_1.DefaultFactory\n};\n//# sourceMappingURL=mylibrary.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Expose all your components to the global scope here.\n\nglobalThis.ThreeGeometryHellfix = globalThis.TGH = require(\"./\").ThreeGeometryHellfix;\n"],"names":["Object","defineProperty","exports","value","DefaultFactory","newVector2","x","y","window","Vector2","newVector3","z","Vector3","newMatrix3","Matrix3","newMatrix4","Matrix4","newObject3D","Object3D","newBox3","Box3","newSphere","Sphere","newBufferGeometry","BufferGeometry","generateUUID","MathUtils","newFloat32BufferAttribute","array","itemSize","normalized","Float32BufferAttribute","newColor","Color","newBufferAttribute","BufferAttribute","DirectGeometry","DefaultFactory_1","factory","this","vertices","normals","colors","uvs","uvs2","groups","morphTargets","skinWeights","skinIndices","boundingBox","boundingSphere","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","prototype","computeGroups","geometry","group","i","materialIndex","undefined","faces","length","face","count","start","push","fromGeometry","morphTargetsPosition","faceVertexUvs","hasFaceVertexUv","hasFaceVertexUv2","morphTargetsLength","name","data","position","morphTargetsNormal","morphNormals","morphNormalsLength","normal","hasSkinIndices","hasSkinWeights","console","error","a","b","c","vertexNormals","vertexUvs","vertexColors","color","warn","j","morphTarget","morphNormal","clone","Face3","isVector3","Array","isArray","isColor","copy","source","il","Gmetry","DirectGeometry_1","Face3_1","type","lineDistances","elementsNeedUpdate","lineDistancesNeedUpdate","isGeometry","uuid","_m1","_obj","_offset","applyMatrix4","matrix","normalMatrix","getNormalMatrix","applyMatrix3","normalize","jl","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","scope","index","attributes","uv","uv2","fromBufferAttribute","addFace","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","computeVertexNormals","areaWeighted","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","sort","newUvs1","newUvs2","uvs1","id","toJSON","metadata","version","generator","parameters","vertex","normalsHash","colorsHash","uvsHash","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","enabled","hash","toString","getHex","srcVertexNormal","destVertexNormal","toBufferGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","name_1","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","dispose","createBufferGeometryFromObject","object","fact","isPoints","isLine","copyArray","Gmetry_1","mylibrary_1","enumerable","get","ThreeGeometryHellfix","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","globalThis","TGH"],"sourceRoot":""}