{"version":3,"file":"three-geometry-hellfix-main.min.js","mappings":"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","sources":["webpack://three-geometry-hellfix/webpack/runtime/chunk loaded","webpack://three-geometry-hellfix/./src/cjs/DirectGeometry.js","webpack://three-geometry-hellfix/./src/cjs/Face3.js","webpack://three-geometry-hellfix/./src/cjs/Gmetry.js","webpack://three-geometry-hellfix/./src/cjs/entry.js","webpack://three-geometry-hellfix/./src/cjs/index.js","webpack://three-geometry-hellfix/./src/cjs/interfaces.js","webpack://three-geometry-hellfix/./src/cjs/mylibrary.js","webpack://three-geometry-hellfix/webpack/bootstrap","webpack://three-geometry-hellfix/webpack/runtime/hasOwnProperty shorthand","webpack://three-geometry-hellfix/webpack/runtime/jsonp chunk loading","webpack://three-geometry-hellfix/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.DirectGeometry class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectGeometry = void 0;\n//  import * as THREE from \"three\";\nvar three_1 = require(\"three\");\nvar DirectGeometry = /** @class */ (function () {\n    // class DirectGeometry {\n    function DirectGeometry() {\n        this.vertices = [];\n        this.normals = [];\n        this.colors = [];\n        this.uvs = [];\n        this.uvs2 = [];\n        this.groups = [];\n        this.morphTargets = {};\n        this.skinWeights = [];\n        this.skinIndices = [];\n        // this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.verticesNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        // this.isGeometry = true;\n    }\n    DirectGeometry.prototype.computeGroups = function (geometry) {\n        var groups = [];\n        var group, i;\n        var materialIndex = undefined;\n        var faces = geometry.faces;\n        for (i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            // materials\n            if (face.materialIndex !== materialIndex) {\n                materialIndex = face.materialIndex;\n                if (group !== undefined) {\n                    group.count = (i * 3) - group.start;\n                    groups.push(group);\n                }\n                group = {\n                    start: i * 3,\n                    materialIndex: materialIndex\n                };\n            }\n        }\n        if (group !== undefined) {\n            group.count = (i * 3) - group.start;\n            groups.push(group);\n        }\n        this.groups = groups;\n    };\n    DirectGeometry.prototype.fromGeometry = function (geometry) {\n        var faces = geometry.faces;\n        var vertices = geometry.vertices;\n        var faceVertexUvs = geometry.faceVertexUvs;\n        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n        // morphs\n        var morphTargets = geometry.morphTargets;\n        var morphTargetsLength = morphTargets.length;\n        var morphTargetsPosition;\n        if (morphTargetsLength > 0) {\n            morphTargetsPosition = [];\n            for (var i = 0; i < morphTargetsLength; i++) {\n                morphTargetsPosition[i] = {\n                    name: morphTargets[i].name,\n                    data: []\n                };\n            }\n            this.morphTargets.position = morphTargetsPosition;\n        }\n        var morphNormals = geometry.morphNormals;\n        var morphNormalsLength = morphNormals.length;\n        var morphTargetsNormal;\n        if (morphNormalsLength > 0) {\n            morphTargetsNormal = [];\n            for (var i = 0; i < morphNormalsLength; i++) {\n                morphTargetsNormal[i] = {\n                    name: morphNormals[i].name,\n                    data: []\n                };\n            }\n            this.morphTargets.normal = morphTargetsNormal;\n        }\n        // skins\n        var skinIndices = geometry.skinIndices;\n        var skinWeights = geometry.skinWeights;\n        var hasSkinIndices = skinIndices.length === vertices.length;\n        var hasSkinWeights = skinWeights.length === vertices.length;\n        //\n        if (vertices.length > 0 && faces.length === 0) {\n            console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n        }\n        for (var i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n            }\n            else {\n                var normal = face.normal;\n                this.normals.push(normal, normal, normal);\n            }\n            var vertexColors = face.vertexColors;\n            if (vertexColors.length === 3) {\n                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n            }\n            else {\n                var color = face.color;\n                this.colors.push(color, color, color);\n            }\n            if (hasFaceVertexUv === true) {\n                var vertexUvs = faceVertexUvs[0][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n                    this.uvs.push(new three_1.Vector2(), new three_1.Vector2(), new three_1.Vector2());\n                }\n            }\n            if (hasFaceVertexUv2 === true) {\n                var vertexUvs = faceVertexUvs[1][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n                    this.uvs2.push(new three_1.Vector2(), new three_1.Vector2(), new three_1.Vector2());\n                }\n            }\n            // morphs\n            for (var j = 0; j < morphTargetsLength; j++) {\n                var morphTarget = morphTargets[j].vertices;\n                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n            }\n            for (var j = 0; j < morphNormalsLength; j++) {\n                var morphNormal = morphNormals[j].vertexNormals[i];\n                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n            }\n            // skins\n            if (hasSkinIndices) {\n                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n            }\n            if (hasSkinWeights) {\n                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n            }\n        }\n        this.computeGroups(geometry);\n        this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n        this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n        this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n        this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n        this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        return this;\n    };\n    return DirectGeometry;\n}());\nexports.DirectGeometry = DirectGeometry;\n//# sourceMappingURL=DirectGeometry.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Face3 = void 0;\n// TODO: only import required types\n// import * as THREE from \"three\";\nvar three_1 = require(\"three\");\nvar Face3 = /** @class */ (function () {\n    function Face3(a, b, c, normal, color, materialIndex) {\n        if (materialIndex === void 0) { materialIndex = 0; }\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        // this.normal = ( normal && normal.isVector3 ) ? normal : new THREE.Vector3();\n        // this.vertexNormals = Array.isArray( normal ) ? normal : [];\n        // TODO: verify correctness\n        this.normal = (normal && (normal instanceof three_1.Vector3 && normal.isVector3)) ? normal : new three_1.Vector3();\n        this.vertexNormals = Array.isArray(normal) ? normal : [];\n        // this.color = ( color && color.isColor ) ? color : new THREE.Color();\n        this.color = (color && (color instanceof three_1.Color && color.isColor)) ? color : new three_1.Color(); // TODO: verify correctness\n        this.vertexColors = Array.isArray(color) ? color : [];\n        this.materialIndex = materialIndex;\n    }\n    Face3.prototype.clone = function () {\n        // TODO: check if new expression is correct\n        // return new this.constructor().copy( this );\n        return new Face3(this.a, this.b, this.c, this.normal.clone(), this.color.clone(), this.materialIndex).copy(this);\n    };\n    Face3.prototype.copy = function (source) {\n        this.a = source.a;\n        this.b = source.b;\n        this.c = source.c;\n        this.normal.copy(source.normal);\n        this.color.copy(source.color);\n        this.materialIndex = source.materialIndex;\n        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n            this.vertexNormals[i] = source.vertexNormals[i].clone();\n        }\n        for (var i = 0, il = source.vertexColors.length; i < il; i++) {\n            this.vertexColors[i] = source.vertexColors[i].clone();\n        }\n        return this;\n    };\n    return Face3;\n}());\nexports.Face3 = Face3;\n//# sourceMappingURL=Face3.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Gmetry = void 0;\nvar three_1 = require(\"three\");\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\nvar _m1 = new three_1.Matrix4();\nvar _obj = new three_1.Object3D();\nvar _offset = new three_1.Vector3();\n// class Geometry extends EventDispatcher {\nvar Gmetry = /** @class */ (function () {\n    function Gmetry() {\n        // super();\n        this.uuid = three_1.MathUtils.generateUUID();\n        this.name = '';\n        this.type = 'Geometry';\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.elementsNeedUpdate = false;\n        this.verticesNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.lineDistancesNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        this.isGeometry = true;\n    }\n    Gmetry.prototype.applyMatrix4 = function (matrix) {\n        var normalMatrix = new three_1.Matrix3().getNormalMatrix(matrix);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var vertex = this.vertices[i];\n            vertex.applyMatrix4(matrix);\n        }\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.normal.applyMatrix3(normalMatrix).normalize();\n            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n            }\n        }\n        if (this.boundingBox !== null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere !== null) {\n            this.computeBoundingSphere();\n        }\n        this.verticesNeedUpdate = true;\n        this.normalsNeedUpdate = true;\n        return this;\n    };\n    Gmetry.prototype.rotateX = function (angle) {\n        // rotate geometry around world x-axis\n        _m1.makeRotationX(angle);\n        this.applyMatrix4(_m1);\n        return this;\n    };\n    Gmetry.prototype.rotateY = function (angle) {\n        // rotate geometry around world y-axis\n        _m1.makeRotationY(angle);\n        this.applyMatrix4(_m1);\n        return this;\n    };\n    Gmetry.prototype.rotateZ = function (angle) {\n        // rotate geometry around world z-axis\n        _m1.makeRotationZ(angle);\n        this.applyMatrix4(_m1);\n        return this;\n    };\n    Gmetry.prototype.translate = function (x, y, z) {\n        // translate geometry\n        _m1.makeTranslation(x, y, z);\n        this.applyMatrix4(_m1);\n        return this;\n    };\n    Gmetry.prototype.scale = function (x, y, z) {\n        // scale geometry\n        _m1.makeScale(x, y, z);\n        this.applyMatrix4(_m1);\n        return this;\n    };\n    Gmetry.prototype.lookAt = function (vector) {\n        _obj.lookAt(vector);\n        _obj.updateMatrix();\n        this.applyMatrix4(_obj.matrix);\n        return this;\n    };\n    Gmetry.prototype.fromBufferGeometry = function (geometry) {\n        var scope = this;\n        var index = geometry.index !== null ? geometry.index : undefined;\n        var attributes = geometry.attributes;\n        if (attributes.position === undefined) {\n            console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n            return this;\n        }\n        var position = attributes.position;\n        var normal = attributes.normal;\n        var color = attributes.color;\n        var uv = attributes.uv;\n        var uv2 = attributes.uv2;\n        if (uv2 !== undefined)\n            this.faceVertexUvs[1] = [];\n        for (var i = 0; i < position.count; i++) {\n            scope.vertices.push(new three_1.Vector3().fromBufferAttribute(position, i));\n            if (color !== undefined) {\n                scope.colors.push(new three_1.Color().fromBufferAttribute(color, i));\n            }\n        }\n        function addFace(a, b, c, materialIndex) {\n            var vertexColors = (color === undefined) ? [] : [\n                scope.colors[a].clone(),\n                scope.colors[b].clone(),\n                scope.colors[c].clone()\n            ];\n            var vertexNormals = (normal === undefined) ? [] : [\n                new three_1.Vector3().fromBufferAttribute(normal, a),\n                new three_1.Vector3().fromBufferAttribute(normal, b),\n                new three_1.Vector3().fromBufferAttribute(normal, c)\n            ];\n            var face = new Face3_1.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n            scope.faces.push(face);\n            if (uv !== undefined) {\n                scope.faceVertexUvs[0].push([\n                    new three_1.Vector2().fromBufferAttribute(uv, a),\n                    new three_1.Vector2().fromBufferAttribute(uv, b),\n                    new three_1.Vector2().fromBufferAttribute(uv, c)\n                ]);\n            }\n            if (uv2 !== undefined) {\n                scope.faceVertexUvs[1].push([\n                    new three_1.Vector2().fromBufferAttribute(uv2, a),\n                    new three_1.Vector2().fromBufferAttribute(uv2, b),\n                    new three_1.Vector2().fromBufferAttribute(uv2, c)\n                ]);\n            }\n        }\n        var groups = geometry.groups;\n        if (groups.length > 0) {\n            for (var i = 0; i < groups.length; i++) {\n                var group = groups[i];\n                var start = group.start;\n                var count = group.count;\n                for (var j = start, jl = start + count; j < jl; j += 3) {\n                    if (index !== undefined) {\n                        addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n                    }\n                    else {\n                        addFace(j, j + 1, j + 2, group.materialIndex);\n                    }\n                }\n            }\n        }\n        else {\n            if (index !== undefined) {\n                for (var i = 0; i < index.count; i += 3) {\n                    addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n                }\n            }\n            else {\n                for (var i = 0; i < position.count; i += 3) {\n                    addFace(i, i + 1, i + 2);\n                }\n            }\n        }\n        this.computeFaceNormals();\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        return this;\n    };\n    Gmetry.prototype.center = function () {\n        this.computeBoundingBox();\n        this.boundingBox.getCenter(_offset).negate();\n        this.translate(_offset.x, _offset.y, _offset.z);\n        return this;\n    };\n    Gmetry.prototype.normalize = function () {\n        this.computeBoundingSphere();\n        var center = this.boundingSphere.center;\n        var radius = this.boundingSphere.radius;\n        var s = radius === 0 ? 1 : 1.0 / radius;\n        var matrix = new three_1.Matrix4();\n        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n        this.applyMatrix4(matrix);\n        return this;\n    };\n    Gmetry.prototype.computeFaceNormals = function () {\n        var cb = new three_1.Vector3(), ab = new three_1.Vector3();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vA = this.vertices[face.a];\n            var vB = this.vertices[face.b];\n            var vC = this.vertices[face.c];\n            cb.subVectors(vC, vB);\n            ab.subVectors(vA, vB);\n            cb.cross(ab);\n            cb.normalize();\n            face.normal.copy(cb);\n        }\n    };\n    Gmetry.prototype.computeVertexNormals = function (areaWeighted) {\n        if (areaWeighted === void 0) { areaWeighted = true; }\n        var vertices = new Array(this.vertices.length);\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            vertices[v] = new three_1.Vector3();\n        }\n        if (areaWeighted) {\n            // vertex normals weighted by triangle areas\n            // http://www.iquilezles.org/www/articles/normals/normals.htm\n            var cb = new three_1.Vector3(), ab = new three_1.Vector3();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var vA = this.vertices[face.a];\n                var vB = this.vertices[face.b];\n                var vC = this.vertices[face.c];\n                cb.subVectors(vC, vB);\n                ab.subVectors(vA, vB);\n                cb.cross(ab);\n                vertices[face.a].add(cb);\n                vertices[face.b].add(cb);\n                vertices[face.c].add(cb);\n            }\n        }\n        else {\n            this.computeFaceNormals();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                vertices[face.a].add(face.normal);\n                vertices[face.b].add(face.normal);\n                vertices[face.c].add(face.normal);\n            }\n        }\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            vertices[v].normalize();\n        }\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(vertices[face.a]);\n                vertexNormals[1].copy(vertices[face.b]);\n                vertexNormals[2].copy(vertices[face.c]);\n            }\n            else {\n                vertexNormals[0] = vertices[face.a].clone();\n                vertexNormals[1] = vertices[face.b].clone();\n                vertexNormals[2] = vertices[face.c].clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeFlatVertexNormals = function () {\n        this.computeFaceNormals();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(face.normal);\n                vertexNormals[1].copy(face.normal);\n                vertexNormals[2].copy(face.normal);\n            }\n            else {\n                vertexNormals[0] = face.normal.clone();\n                vertexNormals[1] = face.normal.clone();\n                vertexNormals[2] = face.normal.clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeMorphNormals = function () {\n        // save original normals\n        // - create temp variables on first access\n        //   otherwise just copy (for faster repeated calls)\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            if (!face.__originalFaceNormal) {\n                face.__originalFaceNormal = face.normal.clone();\n            }\n            else {\n                face.__originalFaceNormal.copy(face.normal);\n            }\n            if (!face.__originalVertexNormals)\n                face.__originalVertexNormals = [];\n            for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n                if (!face.__originalVertexNormals[i]) {\n                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n                }\n                else {\n                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n                }\n            }\n        }\n        // use temp geometry to compute face and vertex normals for each morph\n        // const tmpGeo = new Geometry(); // BEFORE\n        var tmpGeo = new Gmetry();\n        tmpGeo.faces = this.faces;\n        for (var i = 0, il = this.morphTargets.length; i < il; i++) {\n            // create on first access\n            if (!this.morphNormals[i]) {\n                this.morphNormals[i] = {}; // TODO: check\n                this.morphNormals[i].faceNormals = [];\n                this.morphNormals[i].vertexNormals = [];\n                var dstNormalsFace = this.morphNormals[i].faceNormals;\n                var dstNormalsVertex = this.morphNormals[i].vertexNormals;\n                for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                    var faceNormal = new three_1.Vector3();\n                    var vertexNormals = { a: new three_1.Vector3(), b: new three_1.Vector3(), c: new three_1.Vector3() };\n                    dstNormalsFace.push(faceNormal);\n                    dstNormalsVertex.push(vertexNormals);\n                }\n            }\n            var morphNormals = this.morphNormals[i];\n            // set vertices to morph target\n            tmpGeo.vertices = this.morphTargets[i].vertices;\n            // compute morph normals\n            tmpGeo.computeFaceNormals();\n            tmpGeo.computeVertexNormals();\n            // store morph normals\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var faceNormal = morphNormals.faceNormals[f];\n                var vertexNormals = morphNormals.vertexNormals[f];\n                faceNormal.copy(face.normal);\n                vertexNormals.a.copy(face.vertexNormals[0]);\n                vertexNormals.b.copy(face.vertexNormals[1]);\n                vertexNormals.c.copy(face.vertexNormals[2]);\n            }\n        }\n        // restore original normals\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            face.normal = face.__originalFaceNormal;\n            face.vertexNormals = face.__originalVertexNormals;\n        }\n    };\n    Gmetry.prototype.computeBoundingBox = function () {\n        if (this.boundingBox === null) {\n            this.boundingBox = new three_1.Box3();\n        }\n        this.boundingBox.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.computeBoundingSphere = function () {\n        if (this.boundingSphere === null) {\n            this.boundingSphere = new three_1.Sphere();\n        }\n        this.boundingSphere.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.merge = function (geometry, matrix, materialIndexOffset) {\n        if (materialIndexOffset === void 0) { materialIndexOffset = 0; }\n        if (!(geometry && geometry.isGeometry)) {\n            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n            return;\n        }\n        var normalMatrix;\n        var vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\n        if (matrix !== undefined) {\n            normalMatrix = new three_1.Matrix3().getNormalMatrix(matrix);\n        }\n        // vertices\n        for (var i = 0, il = vertices2.length; i < il; i++) {\n            var vertex = vertices2[i];\n            var vertexCopy = vertex.clone();\n            if (matrix !== undefined)\n                vertexCopy.applyMatrix4(matrix);\n            vertices1.push(vertexCopy);\n        }\n        // colors\n        for (var i = 0, il = colors2.length; i < il; i++) {\n            colors1.push(colors2[i].clone());\n        }\n        // faces\n        for (var i = 0, il = faces2.length; i < il; i++) {\n            var face = faces2[i];\n            var normal = void 0, color = void 0;\n            var faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n            var faceCopy = new Face3_1.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n            faceCopy.normal.copy(face.normal);\n            if (normalMatrix !== undefined) {\n                faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n            }\n            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n                normal = faceVertexNormals[j].clone();\n                if (normalMatrix !== undefined) {\n                    normal.applyMatrix3(normalMatrix).normalize();\n                }\n                faceCopy.vertexNormals.push(normal);\n            }\n            faceCopy.color.copy(face.color);\n            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\n                color = faceVertexColors[j];\n                faceCopy.vertexColors.push(color.clone());\n            }\n            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n            faces1.push(faceCopy);\n        }\n        // uvs\n        for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs2 = geometry.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined)\n                this.faceVertexUvs[i] = [];\n            for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n                var uvs2 = faceVertexUvs2[j], uvsCopy = [];\n                for (var k = 0, kl = uvs2.length; k < kl; k++) {\n                    uvsCopy.push(uvs2[k].clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n    };\n    Gmetry.prototype.mergeMesh = function (mesh) {\n        if (!(mesh && mesh.isMesh)) {\n            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n            return;\n        }\n        if (mesh.matrixAutoUpdate)\n            mesh.updateMatrix();\n        this.merge(mesh.geometry, mesh.matrix);\n    };\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n    Gmetry.prototype.mergeVertices = function (precisionPoints) {\n        if (precisionPoints === void 0) { precisionPoints = 4; }\n        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        var unique = [], changes = [];\n        var precision = Math.pow(10, precisionPoints);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var v = this.vertices[i];\n            var key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\n            if (verticesMap[key] === undefined) {\n                verticesMap[key] = i;\n                unique.push(this.vertices[i]);\n                changes[i] = unique.length - 1;\n            }\n            else {\n                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n                changes[i] = changes[verticesMap[key]];\n            }\n        }\n        // if faces are completely degenerate after merging vertices, we\n        // have to remove them from the geometry.\n        var faceIndicesToRemove = [];\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.a = changes[face.a];\n            face.b = changes[face.b];\n            face.c = changes[face.c];\n            var indices = [face.a, face.b, face.c];\n            // if any duplicate vertices are found in a Face3\n            // we have to remove the face as nothing can be saved\n            for (var n = 0; n < 3; n++) {\n                if (indices[n] === indices[(n + 1) % 3]) {\n                    faceIndicesToRemove.push(i);\n                    break;\n                }\n            }\n        }\n        for (var i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n            var idx = faceIndicesToRemove[i];\n            this.faces.splice(idx, 1);\n            for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n                this.faceVertexUvs[j].splice(idx, 1);\n            }\n        }\n        // Use unique set of vertices\n        var diff = this.vertices.length - unique.length;\n        this.vertices = unique;\n        return diff;\n    };\n    Gmetry.prototype.setFromPoints = function (points) {\n        this.vertices = [];\n        for (var i = 0, l = points.length; i < l; i++) {\n            var point = points[i];\n            this.vertices.push(new three_1.Vector3(point.x, point.y, point.z || 0));\n        }\n        return this;\n    };\n    Gmetry.prototype.sortFacesByMaterialIndex = function () {\n        var faces = this.faces;\n        var length = faces.length;\n        // tag faces\n        for (var i = 0; i < length; i++) {\n            faces[i]._id = i;\n        }\n        // sort faces\n        function materialIndexSort(a, b) {\n            return a.materialIndex - b.materialIndex;\n        }\n        faces.sort(materialIndexSort);\n        // sort uvs\n        var uvs1 = this.faceVertexUvs[0];\n        var uvs2 = this.faceVertexUvs[1];\n        var newUvs1, newUvs2;\n        if (uvs1 && uvs1.length === length)\n            newUvs1 = [];\n        if (uvs2 && uvs2.length === length)\n            newUvs2 = [];\n        for (var i = 0; i < length; i++) {\n            var id = faces[i]._id;\n            if (newUvs1)\n                newUvs1.push(uvs1[id]);\n            if (newUvs2)\n                newUvs2.push(uvs2[id]);\n        }\n        if (newUvs1)\n            this.faceVertexUvs[0] = newUvs1;\n        if (newUvs2)\n            this.faceVertexUvs[1] = newUvs2;\n    };\n    Gmetry.prototype.toJSON = function () {\n        var data = {\n            metadata: {\n                version: 4.5,\n                type: 'Geometry',\n                generator: 'Geometry.toJSON'\n            },\n            // TODO: check\n            uuid: null,\n            type: null,\n            name: null,\n            data: null\n        };\n        // standard Geometry serialization\n        data.uuid = this.uuid;\n        data.type = this.type;\n        if (this.name !== '')\n            data.name = this.name;\n        if (this.parameters !== undefined) {\n            var parameters = this.parameters;\n            for (var key in parameters) {\n                if (parameters[key] !== undefined)\n                    data[key] = parameters[key];\n            }\n            return data;\n        }\n        var vertices = [];\n        for (var i = 0; i < this.vertices.length; i++) {\n            var vertex = this.vertices[i];\n            vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n        var faces = [];\n        var normals = [];\n        var normalsHash = {};\n        var colors = [];\n        var colorsHash = {};\n        var uvs = [];\n        var uvsHash = {};\n        for (var i = 0; i < this.faces.length; i++) {\n            var face = this.faces[i];\n            var hasMaterial = true;\n            var hasFaceUv = false; // deprecated\n            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n            var hasFaceNormal = face.normal.length() > 0;\n            var hasFaceVertexNormal = face.vertexNormals.length > 0;\n            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n            var hasFaceVertexColor = face.vertexColors.length > 0;\n            var faceType = 0;\n            faceType = setBit(faceType, 0, 0); // isQuad\n            faceType = setBit(faceType, 1, hasMaterial);\n            faceType = setBit(faceType, 2, hasFaceUv);\n            faceType = setBit(faceType, 3, hasFaceVertexUv);\n            faceType = setBit(faceType, 4, hasFaceNormal);\n            faceType = setBit(faceType, 5, hasFaceVertexNormal);\n            faceType = setBit(faceType, 6, hasFaceColor);\n            faceType = setBit(faceType, 7, hasFaceVertexColor);\n            faces.push(faceType);\n            faces.push(face.a, face.b, face.c);\n            faces.push(face.materialIndex);\n            if (hasFaceVertexUv) {\n                var faceVertexUvs = this.faceVertexUvs[0][i];\n                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n            }\n            if (hasFaceNormal) {\n                faces.push(getNormalIndex(face.normal));\n            }\n            if (hasFaceVertexNormal) {\n                var vertexNormals = face.vertexNormals;\n                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n            }\n            if (hasFaceColor) {\n                faces.push(getColorIndex(face.color));\n            }\n            if (hasFaceVertexColor) {\n                var vertexColors = face.vertexColors;\n                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n            }\n        }\n        function setBit(value, position, enabled) {\n            return enabled ? value | (1 << position) : value & (~(1 << position));\n        }\n        function getNormalIndex(normal) {\n            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n            if (normalsHash[hash] !== undefined) {\n                return normalsHash[hash];\n            }\n            normalsHash[hash] = normals.length / 3;\n            normals.push(normal.x, normal.y, normal.z);\n            return normalsHash[hash];\n        }\n        function getColorIndex(color) {\n            var hash = color.r.toString() + color.g.toString() + color.b.toString();\n            if (colorsHash[hash] !== undefined) {\n                return colorsHash[hash];\n            }\n            colorsHash[hash] = colors.length;\n            colors.push(color.getHex());\n            return colorsHash[hash];\n        }\n        function getUvIndex(uv) {\n            var hash = uv.x.toString() + uv.y.toString();\n            if (uvsHash[hash] !== undefined) {\n                return uvsHash[hash];\n            }\n            uvsHash[hash] = uvs.length / 2;\n            uvs.push(uv.x, uv.y);\n            return uvsHash[hash];\n        }\n        data.data = {};\n        data.data.vertices = vertices;\n        data.data.normals = normals;\n        if (colors.length > 0)\n            data.data.colors = colors;\n        if (uvs.length > 0)\n            data.data.uvs = [uvs]; // temporal backward compatibility\n        data.data.faces = faces;\n        return data;\n    };\n    Gmetry.prototype.clone = function () {\n        /*\n         // Handle primitives\n\n         const parameters = this.parameters;\n\n         if ( parameters !== undefined ) {\n\n         const values = [];\n\n         for ( const key in parameters ) {\n\n         values.push( parameters[ key ] );\n\n         }\n\n         const geometry = Object.create( this.constructor.prototype );\n         this.constructor.apply( geometry, values );\n         return geometry;\n\n         }\n\n         return new this.constructor().copy( this );\n         */\n        // return new Geometry().copy( this ); // BEFORE\n        return new Gmetry().copy(this);\n    };\n    Gmetry.prototype.copy = function (source) {\n        // reset\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // name\n        this.name = source.name;\n        // vertices\n        var vertices = source.vertices;\n        for (var i = 0, il = vertices.length; i < il; i++) {\n            this.vertices.push(vertices[i].clone());\n        }\n        // colors\n        var colors = source.colors;\n        for (var i = 0, il = colors.length; i < il; i++) {\n            this.colors.push(colors[i].clone());\n        }\n        // faces\n        var faces = source.faces;\n        for (var i = 0, il = faces.length; i < il; i++) {\n            this.faces.push(faces[i].clone());\n        }\n        // face vertex uvs\n        for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs = source.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n                var uvs = faceVertexUvs[j], uvsCopy = [];\n                for (var k = 0, kl = uvs.length; k < kl; k++) {\n                    var uv = uvs[k];\n                    uvsCopy.push(uv.clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n        // morph targets\n        var morphTargets = source.morphTargets;\n        for (var i = 0, il = morphTargets.length; i < il; i++) {\n            var morphTarget = {}; // // TODO: check\n            morphTarget.name = morphTargets[i].name;\n            // vertices\n            if (morphTargets[i].vertices !== undefined) {\n                morphTarget.vertices = [];\n                for (var j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n                    morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n                }\n            }\n            // normals\n            if (morphTargets[i].normals !== undefined) {\n                morphTarget.normals = [];\n                for (var j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n                    morphTarget.normals.push(morphTargets[i].normals[j].clone());\n                }\n            }\n            this.morphTargets.push(morphTarget);\n        }\n        // morph normals\n        var morphNormals = source.morphNormals;\n        for (var i = 0, il = morphNormals.length; i < il; i++) {\n            var morphNormal = {}; // TODO: check\n            // vertex normals\n            if (morphNormals[i].vertexNormals !== undefined) {\n                morphNormal.vertexNormals = [];\n                for (var j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n                    var srcVertexNormal = morphNormals[i].vertexNormals[j];\n                    // TODO: add type\n                    var destVertexNormal = { a: null, b: null, c: null }; // TODO: check\n                    destVertexNormal.a = srcVertexNormal.a.clone();\n                    destVertexNormal.b = srcVertexNormal.b.clone();\n                    destVertexNormal.c = srcVertexNormal.c.clone();\n                    morphNormal.vertexNormals.push(destVertexNormal);\n                }\n            }\n            // face normals\n            if (morphNormals[i].faceNormals !== undefined) {\n                morphNormal.faceNormals = [];\n                for (var j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n                    morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n                }\n            }\n            this.morphNormals.push(morphNormal);\n        }\n        // skin weights\n        var skinWeights = source.skinWeights;\n        for (var i = 0, il = skinWeights.length; i < il; i++) {\n            this.skinWeights.push(skinWeights[i].clone());\n        }\n        // skin indices\n        var skinIndices = source.skinIndices;\n        for (var i = 0, il = skinIndices.length; i < il; i++) {\n            this.skinIndices.push(skinIndices[i].clone());\n        }\n        // line distances\n        var lineDistances = source.lineDistances;\n        for (var i = 0, il = lineDistances.length; i < il; i++) {\n            this.lineDistances.push(lineDistances[i]);\n        }\n        // bounding box\n        var boundingBox = source.boundingBox;\n        if (boundingBox !== null) {\n            this.boundingBox = boundingBox.clone();\n        }\n        // bounding sphere\n        var boundingSphere = source.boundingSphere;\n        if (boundingSphere !== null) {\n            this.boundingSphere = boundingSphere.clone();\n        }\n        // update flags\n        this.elementsNeedUpdate = source.elementsNeedUpdate;\n        this.verticesNeedUpdate = source.verticesNeedUpdate;\n        this.uvsNeedUpdate = source.uvsNeedUpdate;\n        this.normalsNeedUpdate = source.normalsNeedUpdate;\n        this.colorsNeedUpdate = source.colorsNeedUpdate;\n        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n        this.groupsNeedUpdate = source.groupsNeedUpdate;\n        return this;\n    };\n    Gmetry.prototype.toBufferGeometry = function () {\n        var geometry = new DirectGeometry_1.DirectGeometry().fromGeometry(this);\n        var buffergeometry = new three_1.BufferGeometry();\n        var positions = new Float32Array(geometry.vertices.length * 3);\n        buffergeometry.setAttribute('position', new three_1.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n        if (geometry.normals.length > 0) {\n            var normals = new Float32Array(geometry.normals.length * 3);\n            buffergeometry.setAttribute('normal', new three_1.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n        }\n        if (geometry.colors.length > 0) {\n            var colors = new Float32Array(geometry.colors.length * 3);\n            buffergeometry.setAttribute('color', new three_1.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n        }\n        if (geometry.uvs.length > 0) {\n            var uvs = new Float32Array(geometry.uvs.length * 2);\n            buffergeometry.setAttribute('uv', new three_1.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n        }\n        if (geometry.uvs2.length > 0) {\n            var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n            buffergeometry.setAttribute('uv2', new three_1.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n        }\n        // groups\n        buffergeometry.groups = geometry.groups;\n        // morphs\n        for (var name_1 in geometry.morphTargets) {\n            var array = [];\n            var morphTargets = geometry.morphTargets[name_1];\n            for (var i = 0, l = morphTargets.length; i < l; i++) {\n                var morphTarget = morphTargets[i];\n                var attribute = new three_1.Float32BufferAttribute(morphTarget.data.length * 3, 3);\n                attribute.name = morphTarget.name;\n                array.push(attribute.copyVector3sArray(morphTarget.data));\n            }\n            buffergeometry.morphAttributes[name_1] = array;\n        }\n        // skinning\n        if (geometry.skinIndices.length > 0) {\n            var skinIndices = new three_1.Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n            buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n        }\n        if (geometry.skinWeights.length > 0) {\n            var skinWeights = new three_1.Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n            buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n        }\n        //\n        if (geometry.boundingSphere !== null) {\n            buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            buffergeometry.boundingBox = geometry.boundingBox.clone();\n        }\n        return buffergeometry;\n    };\n    Gmetry.prototype.computeTangents = function () {\n        console.error('THREE.Geometry: .computeTangents() has been removed.');\n    };\n    Gmetry.prototype.computeLineDistances = function () {\n        console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n    };\n    Gmetry.prototype.applyMatrix = function (matrix) {\n        console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n        return this.applyMatrix4(matrix);\n    };\n    Gmetry.prototype.dispose = function () {\n        // This is not required when used outside of THREE.\n        // this.dispatchEvent( { type: 'dispose' } );\n    };\n    Gmetry.createBufferGeometryFromObject = function (object) {\n        var buffergeometry = new three_1.BufferGeometry();\n        var geometry = object.geometry;\n        if (object.isPoints || object.isLine) {\n            var positions = new three_1.Float32BufferAttribute(geometry.vertices.length * 3, 3);\n            var colors = new three_1.Float32BufferAttribute(geometry.colors.length * 3, 3);\n            buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n            buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n                var lineDistances = new three_1.Float32BufferAttribute(geometry.lineDistances.length, 1);\n                buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n            }\n            if (geometry.boundingSphere !== null) {\n                buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n            }\n            if (geometry.boundingBox !== null) {\n                buffergeometry.boundingBox = geometry.boundingBox.clone();\n            }\n        }\n        else if (object.isMesh) {\n            buffergeometry = geometry.toBufferGeometry();\n        }\n        return buffergeometry;\n    };\n    return Gmetry;\n}());\nexports.Gmetry = Gmetry;\n// Geometry.prototype.isGeometry = true;\n// class DirectGeometry {\n// \tconstructor() {\n// \t\tthis.vertices = [];\n// \t\tthis.normals = [];\n// \t\tthis.colors = [];\n// \t\tthis.uvs = [];\n// \t\tthis.uvs2 = [];\n// \t\tthis.groups = [];\n// \t\tthis.morphTargets = {};\n// \t\tthis.skinWeights = [];\n// \t\tthis.skinIndices = [];\n// \t\t// this.lineDistances = [];\n// \t\tthis.boundingBox = null;\n// \t\tthis.boundingSphere = null;\n// \t\t// update flags\n// \t\tthis.verticesNeedUpdate = false;\n// \t\tthis.normalsNeedUpdate = false;\n// \t\tthis.colorsNeedUpdate = false;\n// \t\tthis.uvsNeedUpdate = false;\n// \t\tthis.groupsNeedUpdate = false;\n// \t\tthis.isGeometry = true;\n// \t}\n// \tcomputeGroups( geometry ) {\n// \t\tconst groups = [];\n// \t\tlet group, i;\n// \t\tlet materialIndex = undefined;\n// \t\tconst faces = geometry.faces;\n// \t\tfor ( i = 0; i < faces.length; i ++ ) {\n// \t\t\tconst face = faces[ i ];\n// \t\t\t// materials\n// \t\t\tif ( face.materialIndex !== materialIndex ) {\n// \t\t\t\tmaterialIndex = face.materialIndex;\n// \t\t\t\tif ( group !== undefined ) {\n// \t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n// \t\t\t\t\tgroups.push( group );\n// \t\t\t\t}\n// \t\t\t\tgroup = {\n// \t\t\t\t\tstart: i * 3,\n// \t\t\t\t\tmaterialIndex: materialIndex\n// \t\t\t\t};\n// \t\t\t}\n// \t\t}\n// \t\tif ( group !== undefined ) {\n// \t\t\tgroup.count = ( i * 3 ) - group.start;\n// \t\t\tgroups.push( group );\n// \t\t}\n// \t\tthis.groups = groups;\n// \t}\n// \tfromGeometry( geometry ) {\n// \t\tconst faces = geometry.faces;\n// \t\tconst vertices = geometry.vertices;\n// \t\tconst faceVertexUvs = geometry.faceVertexUvs;\n// \t\tconst hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n// \t\tconst hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n// \t\t// morphs\n// \t\tconst morphTargets = geometry.morphTargets;\n// \t\tconst morphTargetsLength = morphTargets.length;\n// \t\tlet morphTargetsPosition;\n// \t\tif ( morphTargetsLength > 0 ) {\n// \t\t\tmorphTargetsPosition = [];\n// \t\t\tfor ( let i = 0; i < morphTargetsLength; i ++ ) {\n// \t\t\t\tmorphTargetsPosition[ i ] = {\n// \t\t\t\t\tname: morphTargets[ i ].name,\n// \t\t\t\t \tdata: []\n// \t\t\t\t};\n// \t\t\t}\n// \t\t\tthis.morphTargets.position = morphTargetsPosition;\n// \t\t}\n// \t\tconst morphNormals = geometry.morphNormals;\n// \t\tconst morphNormalsLength = morphNormals.length;\n// \t\tlet morphTargetsNormal;\n// \t\tif ( morphNormalsLength > 0 ) {\n// \t\t\tmorphTargetsNormal = [];\n// \t\t\tfor ( let i = 0; i < morphNormalsLength; i ++ ) {\n// \t\t\t\tmorphTargetsNormal[ i ] = {\n// \t\t\t\t\tname: morphNormals[ i ].name,\n// \t\t\t\t \tdata: []\n// \t\t\t\t};\n// \t\t\t}\n// \t\t\tthis.morphTargets.normal = morphTargetsNormal;\n// \t\t}\n// \t\t// skins\n// \t\tconst skinIndices = geometry.skinIndices;\n// \t\tconst skinWeights = geometry.skinWeights;\n// \t\tconst hasSkinIndices = skinIndices.length === vertices.length;\n// \t\tconst hasSkinWeights = skinWeights.length === vertices.length;\n// \t\t//\n// \t\tif ( vertices.length > 0 && faces.length === 0 ) {\n// \t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n// \t\t}\n// \t\tfor ( let i = 0; i < faces.length; i ++ ) {\n// \t\t\tconst face = faces[ i ];\n// \t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n// \t\t\tconst vertexNormals = face.vertexNormals;\n// \t\t\tif ( vertexNormals.length === 3 ) {\n// \t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n// \t\t\t} else {\n// \t\t\t\tconst normal = face.normal;\n// \t\t\t\tthis.normals.push( normal, normal, normal );\n// \t\t\t}\n// \t\t\tconst vertexColors = face.vertexColors;\n// \t\t\tif ( vertexColors.length === 3 ) {\n// \t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n// \t\t\t} else {\n// \t\t\t\tconst color = face.color;\n// \t\t\t\tthis.colors.push( color, color, color );\n// \t\t\t}\n// \t\t\tif ( hasFaceVertexUv === true ) {\n// \t\t\t\tconst vertexUvs = faceVertexUvs[ 0 ][ i ];\n// \t\t\t\tif ( vertexUvs !== undefined ) {\n// \t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n// \t\t\t\t} else {\n// \t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n// \t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tif ( hasFaceVertexUv2 === true ) {\n// \t\t\t\tconst vertexUvs = faceVertexUvs[ 1 ][ i ];\n// \t\t\t\tif ( vertexUvs !== undefined ) {\n// \t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n// \t\t\t\t} else {\n// \t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n// \t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// morphs\n// \t\t\tfor ( let j = 0; j < morphTargetsLength; j ++ ) {\n// \t\t\t\tconst morphTarget = morphTargets[ j ].vertices;\n// \t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n// \t\t\t}\n// \t\t\tfor ( let j = 0; j < morphNormalsLength; j ++ ) {\n// \t\t\t\tconst morphNormal = morphNormals[ j ].vertexNormals[ i ];\n// \t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n// \t\t\t}\n// \t\t\t// skins\n// \t\t\tif ( hasSkinIndices ) {\n// \t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n// \t\t\t}\n// \t\t\tif ( hasSkinWeights ) {\n// \t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n// \t\t\t}\n// \t\t}\n// \t\tthis.computeGroups( geometry );\n// \t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n// \t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n// \t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n// \t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n// \t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n// \t\tif ( geometry.boundingSphere !== null ) {\n// \t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n// \t\t}\n// \t\tif ( geometry.boundingBox !== null ) {\n// \t\t\tthis.boundingBox = geometry.boundingBox.clone();\n// \t\t}\n// \t\treturn this;\n// \t}\n// }\n// class Face3 {\n// \tconstructor( a, b, c, normal, color, materialIndex = 0 ) {\n// \t\tthis.a = a;\n// \t\tthis.b = b;\n// \t\tthis.c = c;\n// \t\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n// \t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n// \t\tthis.color = ( color && color.isColor ) ? color : new Color();\n// \t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n// \t\tthis.materialIndex = materialIndex;\n// \t}\n// \tclone() {\n// \t\treturn new this.constructor().copy( this );\n// \t}\n// \tcopy( source ) {\n// \t\tthis.a = source.a;\n// \t\tthis.b = source.b;\n// \t\tthis.c = source.c;\n// \t\tthis.normal.copy( source.normal );\n// \t\tthis.color.copy( source.color );\n// \t\tthis.materialIndex = source.materialIndex;\n// \t\tfor ( let i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n// \t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n// \t\t}\n// \t\tfor ( let i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n// \t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n// \t\t}\n// \t\treturn this;\n// \t}\n// }\n// export { Face3, Gmetry };\n//# sourceMappingURL=Gmetry.js.map","// Expose all your components to the global scope here.\n\nglobalThis.ThreeGeometryHellfix = globalThis.TGH = require(\"./\").ThreeGeometryHellfix;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./DirectGeometry\"), exports);\n__exportStar(require(\"./Face3\"), exports);\n__exportStar(require(\"./Gmetry\"), exports);\n__exportStar(require(\"./interfaces\"), exports);\n__exportStar(require(\"./mylibrary\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=interfaces.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeGeometryHellfix = void 0;\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\nvar Gmetry_1 = require(\"./Gmetry\");\nexports.ThreeGeometryHellfix = {\n    DirectGeometry: DirectGeometry_1.DirectGeometry,\n    Face3: Face3_1.Face3,\n    Gmetry: Gmetry_1.Gmetry\n};\n//# sourceMappingURL=mylibrary.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkIds[i]] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkthree_geometry_hellfix\"] = self[\"webpackChunkthree_geometry_hellfix\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [736], () => (__webpack_require__(333)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","Object","defineProperty","exports","value","DirectGeometry","three_1","this","vertices","normals","colors","uvs","uvs2","groups","morphTargets","skinWeights","skinIndices","boundingBox","boundingSphere","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","prototype","computeGroups","geometry","group","i","materialIndex","undefined","faces","length","face","count","start","push","fromGeometry","morphTargetsPosition","faceVertexUvs","hasFaceVertexUv","hasFaceVertexUv2","morphTargetsLength","name","data","position","morphTargetsNormal","morphNormals","morphNormalsLength","normal","hasSkinIndices","hasSkinWeights","console","error","a","b","c","vertexNormals","vertexUvs","vertexColors","color","warn","Vector2","j","morphTarget","morphNormal","clone","Face3","Vector3","isVector3","Array","isArray","Color","isColor","copy","source","il","Gmetry","DirectGeometry_1","Face3_1","_m1","Matrix4","_obj","Object3D","_offset","uuid","MathUtils","generateUUID","type","lineDistances","elementsNeedUpdate","lineDistancesNeedUpdate","isGeometry","applyMatrix4","matrix","normalMatrix","Matrix3","getNormalMatrix","applyMatrix3","normalize","jl","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","scope","index","attributes","uv","uv2","fromBufferAttribute","addFace","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","computeVertexNormals","areaWeighted","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","Box3","setFromPoints","Sphere","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","sort","newUvs1","newUvs2","uvs1","id","toJSON","metadata","version","generator","parameters","vertex","normalsHash","colorsHash","uvsHash","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","enabled","hash","toString","getHex","srcVertexNormal","destVertexNormal","toBufferGeometry","buffergeometry","BufferGeometry","positions","Float32Array","setAttribute","BufferAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","name_1","array","attribute","Float32BufferAttribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","dispose","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","globalThis","ThreeGeometryHellfix","TGH","__createBinding","create","o","m","k2","enumerable","get","__exportStar","p","hasOwnProperty","call","Gmetry_1","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","keys","every","obj","prop","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","forEach","bind","__webpack_exports__"],"sourceRoot":""}